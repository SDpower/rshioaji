use std::env;
use std::path::Path;
use std::time::{SystemTime, UNIX_EPOCH};
use chrono::{DateTime, Utc, Timelike};
use log::{Level, LevelFilter};
use serde_json;
use crate::types::{Contracts, FetchStatus};

/// Â∞çÊáâÂéüÂßã Python ÁöÑ allow_log_level
pub const ALLOWED_LOG_LEVELS: &[&str] = &["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"];

/// Â∞çÊáâÂéüÂßã Python ÁöÑÈ†êË®≠ SENTRY_URI
pub const DEFAULT_SENTRY_URI: &str = "https://6aec6ef8db7148aa979a17453c0e44dd@sentry.io/1371618";

/// Â∞çÊáâÂéüÂßã Python ÁöÑÈ†êË®≠ SJ_LOG_PATH
pub const DEFAULT_SJ_LOG_PATH: &str = "shioaji.log";

/// Áí∞Â¢ÉËÆäÊï∏ÈÖçÁΩÆÁµêÊßã
#[derive(Debug, Clone)]
pub struct EnvironmentConfig {
    /// Êó•Ë™åÁ≠âÁ¥öÔºåÈ†êË®≠ÁÇ∫ INFO
    pub log_level: String,
    /// Sentry ÈåØË™§ËøΩËπ§ URI
    pub sentry_uri: String,
    /// ÊòØÂê¶ÂïüÁî® Sentry Êó•Ë™åÔºåÈ†êË®≠ÁÇ∫ true
    pub log_sentry: bool,
    /// Sentry Êó•Ë™åÁ≠âÁ¥öÔºåÈ†êË®≠ÁÇ∫ ERROR
    pub sentry_log_level: String,
    /// Êó•Ë™åÊ™îÊ°àË∑ØÂæëÔºåÈ†êË®≠ÁÇ∫ shioaji.log
    pub sj_log_path: String,
    /// ÈÅ∫ÁïôÊ∏¨Ë©¶Ê®°ÂºèÔºåÈ†êË®≠ÁÇ∫ 0
    pub legacy_test: i32,
}

impl Default for EnvironmentConfig {
    fn default() -> Self {
        Self {
            log_level: "INFO".to_string(),
            sentry_uri: DEFAULT_SENTRY_URI.to_string(),
            log_sentry: true,
            sentry_log_level: "ERROR".to_string(),
            sj_log_path: DEFAULT_SJ_LOG_PATH.to_string(),
            legacy_test: 0,
        }
    }
}

impl EnvironmentConfig {
    /// ÂæûÁí∞Â¢ÉËÆäÊï∏ËºâÂÖ•ÈÖçÁΩÆ
    pub fn from_env() -> Self {
        let log_level = env::var("LOG_LEVEL")
            .unwrap_or_else(|_| "INFO".to_string())
            .to_uppercase();
        
        let sentry_uri = env::var("SENTRY_URI")
            .unwrap_or_else(|_| DEFAULT_SENTRY_URI.to_string());
        
        let log_sentry = env::var("LOG_SENTRY")
            .unwrap_or_else(|_| "True".to_string())
            .to_lowercase() == "true";
        
        let sentry_log_level = env::var("SENTRY_LOG_LEVEL")
            .unwrap_or_else(|_| "ERROR".to_string())
            .to_uppercase();
        
        let sj_log_path = env::var("SJ_LOG_PATH")
            .unwrap_or_else(|_| DEFAULT_SJ_LOG_PATH.to_string());
        
        let legacy_test = env::var("LEGACY_TEST")
            .unwrap_or_else(|_| "0".to_string())
            .parse::<i32>()
            .unwrap_or(0);
        
        Self {
            log_level,
            sentry_uri,
            log_sentry,
            sentry_log_level,
            sj_log_path,
            legacy_test,
        }
    }
    
    /// È©óË≠âÈÖçÁΩÆÊòØÂê¶ÊúâÊïà
    /// 
    /// Â∞çÊáâÂéüÂßã Python È©óË≠âÔºö
    /// ```python
    /// assert LOG_LEVEL in allow_log_level, "LOG_LEVEL not allow, choice {}".format(
    ///     (", ").join(allow_log_level)
    /// )
    /// ```
    pub fn validate(&self) -> Result<(), String> {
        if !ALLOWED_LOG_LEVELS.contains(&self.log_level.as_str()) {
            return Err(format!(
                "LOG_LEVEL not allow, choice {}",
                ALLOWED_LOG_LEVELS.join(", ")
            ));
        }
        
        if !ALLOWED_LOG_LEVELS.contains(&self.sentry_log_level.as_str()) {
            return Err(format!(
                "SENTRY_LOG_LEVEL not allow, choice {}",
                ALLOWED_LOG_LEVELS.join(", ")
            ));
        }
        
        Ok(())
    }
    
    /// ËΩâÊèõÁÇ∫ log::LevelFilter
    pub fn get_log_level_filter(&self) -> LevelFilter {
        match self.log_level.as_str() {
            "DEBUG" => LevelFilter::Debug,
            "INFO" => LevelFilter::Info,
            "WARNING" => LevelFilter::Warn,
            "ERROR" => LevelFilter::Error,
            "CRITICAL" => LevelFilter::Error, // Rust Ê≤íÊúâ CriticalÔºå‰ΩøÁî® Error
            _ => LevelFilter::Info,
        }
    }
    
    /// ËΩâÊèõÁÇ∫ log::Level
    pub fn get_log_level(&self) -> Level {
        match self.log_level.as_str() {
            "DEBUG" => Level::Debug,
            "INFO" => Level::Info,
            "WARNING" => Level::Warn,
            "ERROR" => Level::Error,
            "CRITICAL" => Level::Error,
            _ => Level::Info,
        }
    }
    
    /// Áç≤Âèñ Sentry Êó•Ë™åÁ≠âÁ¥ö
    pub fn get_sentry_log_level_filter(&self) -> LevelFilter {
        match self.sentry_log_level.as_str() {
            "DEBUG" => LevelFilter::Debug,
            "INFO" => LevelFilter::Info,
            "WARNING" => LevelFilter::Warn,
            "ERROR" => LevelFilter::Error,
            "CRITICAL" => LevelFilter::Error,
            _ => LevelFilter::Error,
        }
    }
    
    /// È°ØÁ§∫ÈÖçÁΩÆÊëòË¶Å
    pub fn summary(&self) -> String {
        format!(
            "Environment Config: log_level={}, sentry_enabled={}, sentry_log_level={}, log_path={}, legacy_test={}",
            self.log_level,
            self.log_sentry,
            self.sentry_log_level,
            self.sj_log_path,
            self.legacy_test
        )
    }
}

/// ÂàùÂßãÂåñÊó•Ë™åÁ≥ªÁµ±
/// 
/// Â∞çÊáâÂéüÂßã Python Êó•Ë™åË®≠ÂÆöÔºö
/// ```python
/// console_handler = logging.FileHandler(SJ_LOG_PATH)
/// console_handler.setLevel(LOGGING_LEVEL)
/// log_formatter = logging.Formatter(
///     "[%(levelname)1.1s %(asctime)s %(pathname)s:%(lineno)d:%(funcName)s] %(message)s"
/// )
/// console_handler.setFormatter(log_formatter)
/// log.addHandler(console_handler)
/// ```
pub fn init_logging(config: &EnvironmentConfig) -> Result<(), Box<dyn std::error::Error>> {
    use env_logger::{Builder, Target};
    use std::io::Write;
    
    let mut builder = Builder::new();
    
    // Ë®≠ÂÆöÊó•Ë™åÁ≠âÁ¥ö
    builder.filter_level(config.get_log_level_filter());
    
    // Ë®≠ÂÆöÊó•Ë™åÊ†ºÂºèÔºàÂÆåÂÖ®Â∞çÊáâ Python ÁâàÊú¨ÁöÑÊ†ºÂºèÔºâ
    // Python: "[%(levelname)1.1s %(asctime)s %(pathname)s:%(lineno)d:%(funcName)s] %(message)s"
    builder.format(|buf, record| {
        writeln!(buf,
            "[{} {} {}:{}:{}] {}",
            match record.level() {
                Level::Error => "E",
                Level::Warn => "W", 
                Level::Info => "I",
                Level::Debug => "D",
                Level::Trace => "T",
            },
            chrono::Utc::now().format("%Y-%m-%d %H:%M:%S%.6f"),  // Â∞çÊáâ Python ÁöÑ asctime
            record.file().unwrap_or("unknown"),                  // Â∞çÊáâ Python ÁöÑ pathname
            record.line().unwrap_or(0),                         // Â∞çÊáâ Python ÁöÑ lineno
            record.target(),                                     // Â∞çÊáâ Python ÁöÑ funcName
            record.args()                                        // Â∞çÊáâ Python ÁöÑ message
        )
    });
    
    // Ë®≠ÂÆöËº∏Âá∫ÁõÆÊ®ôÔºàÂ∞çÊáâ Python ÁöÑ FileHandlerÔºâ
    if config.sj_log_path != "console" {
        builder.target(Target::Pipe(Box::new(std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&config.sj_log_path)?)));
    }
    
    builder.init();
    
    log::info!("üîß Êó•Ë™åÁ≥ªÁµ±ÂàùÂßãÂåñÂÆåÊàê");
    log::info!("üìã {}", config.summary());
    
    Ok(())
}

/// Ë®≠ÂÆöÈåØË™§ËøΩËπ§Á≥ªÁµ±
pub fn set_error_tracking(simulation: bool, error_tracking: bool, config: &EnvironmentConfig) {
    if config.log_sentry && !simulation && error_tracking {
        // Âú® Rust ‰∏≠ÔºåÊàëÂÄëÂèØ‰ª•‰ΩøÁî® sentry crate ‰æÜË®≠ÂÆöÈåØË™§ËøΩËπ§
        // ‰ΩÜÁî±ÊñºÈÄôÊòØÂèØÈÅ∏ÂäüËÉΩÔºåÊàëÂÄëÂÖàË®òÈåÑÊó•Ë™å
        log::info!("üõ°Ô∏è  ÈåØË™§ËøΩËπ§Á≥ªÁµ±ÂïüÁî®");
        log::debug!("Sentry URI: {}", config.sentry_uri);
        log::debug!("Sentry Log Level: {}", config.sentry_log_level);
        
        // Â¶ÇÊûúÈúÄË¶ÅÂØ¶ÈöõÁöÑ Sentry Êï¥ÂêàÔºåÂèØ‰ª•Âú®ÈÄôË£°Âä†ÂÖ•
        #[cfg(feature = "sentry")]
        {
            let _guard = sentry::init(sentry::ClientOptions {
                dsn: Some(config.sentry_uri.parse().unwrap()),
                release: sentry::release_name!(),
                ..Default::default()
            });
            log::info!("‚úÖ Sentry ÈåØË™§ËøΩËπ§Â∑≤ÂïüÁî®");
        }
        
        #[cfg(not(feature = "sentry"))]
        {
            log::warn!("‚ö†Ô∏è  Sentry ÂäüËÉΩÊú™ÂïüÁî®ÔºåË´ã‰ΩøÁî® --features sentry Á∑®Ë≠Ø");
        }
    } else {
        log::debug!("ÈåØË™§ËøΩËπ§Á≥ªÁµ±Êú™ÂïüÁî® (simulation={}, error_tracking={}, log_sentry={})",
                   simulation, error_tracking, config.log_sentry);
    }
}

/// Âª∫Á´ãË∂ÖÊôÇÈåØË™§ÔºàÂ∞çÊáâ Python ÁöÑ timeout_exceptionÔºâ
/// 
/// Â∞çÊáâÂéüÂßã Python ÂáΩÊï∏Ôºö
/// ```python
/// def timeout_exception(func, resp: httpx.Response, session: SolClient):
///     log.error(f"{func}: {resp.text}")
///     session.disconnect()
///     raise Timeout(resp.status_code, resp.text)
/// ```
pub fn timeout_exception(func: &str, status_code: u16, resp_text: &str) -> crate::error::Error {
    log::error!("{}: {}", func, resp_text);
    crate::error::Error::Timeout(format!("Timeout in {}: HTTP {} - {}", func, status_code, resp_text))
}

/// ÂõûÊáâÈåØË™§ËôïÁêÜÔºàÂ∞çÊáâ Python ÁöÑ raise_resp_errorÔºâ
/// 
/// Â∞çÊáâÂéüÂßã Python ÂáΩÊï∏Ôºö
/// ```python
/// def raise_resp_error(status_code: int, resp: dict, session: SolClient):
///     log.error(resp)
///     detail = resp.get("response", {}).get("detail", "")
///     if status_code == 401:
///         session.disconnect()
///         raise TokenError(status_code, detail)
///     elif status_code == 503:
///         raise SystemMaintenance(status_code, detail)
///     else:
///         raise Exception(resp)
/// ```
pub fn raise_resp_error(status_code: u16, resp: serde_json::Value) -> crate::error::Error {
    log::error!("API ÈåØË™§ [{}]: {}", status_code, resp);
    
    // ÊèêÂèñË©≥Á¥∞ÈåØË™§Ë®äÊÅØÔºàÂ∞çÊáâ Python ÁöÑ resp.get("response", {}).get("detail", "")Ôºâ
    let detail = resp
        .get("response")
        .and_then(|r| r.get("detail"))
        .and_then(|d| d.as_str())
        .unwrap_or("")
        .to_string();
    
    match status_code {
        401 => {
            // TokenError - Â∞çÊáâ Python ÁöÑ TokenError(status_code, detail)
            crate::error::Error::Authentication(format!("Token Error {}: {}", status_code, detail))
        },
        503 => {
            // SystemMaintenance - Â∞çÊáâ Python ÁöÑ SystemMaintenance(status_code, detail)
            crate::error::Error::Api(format!("System Maintenance {}: {}", status_code, detail))
        },
        _ => {
            // ÂÖ∂‰ªñÈåØË™§ - Â∞çÊáâ Python ÁöÑ Exception(resp)
            crate::error::Error::Api(format!("HTTP {}: {}", status_code, resp))
        }
    }
}

/// Ê™¢Êü•ÂõûÊáâÁãÄÊÖãÁ¢º‰∏¶ËôïÁêÜÈåØË™§ÔºàÂ∞çÊáâ Python ÁöÑ status_error_wrapperÔºâ
/// 
/// Â∞çÊáâÂéüÂßã Python ÂáΩÊï∏Ôºö
/// ```python
/// def status_error_wrapper(resp: httpx.Response):
///     if resp.status_code in [200, 207]:
///         return resp.json() if resp.text else {}
///     else:
///         raise_resp_error(resp.status_code, resp.json(), self._session)
/// ```
pub fn status_error_wrapper(status_code: u16, resp_text: &str) -> Result<serde_json::Value, crate::error::Error> {
    if status_code == 200 || status_code == 207 {
        if resp_text.is_empty() {
            Ok(serde_json::Value::Object(serde_json::Map::new()))
        } else {
            serde_json::from_str(resp_text)
                .map_err(|e| crate::error::Error::Api(format!("JSON Ëß£ÊûêÈåØË™§: {}", e)))
        }
    } else {
        let resp_json = serde_json::from_str(resp_text)
            .unwrap_or_else(|_| serde_json::json!({"error": resp_text}));
        Err(raise_resp_error(status_code, resp_json))
    }
}

/// Ê∏ÖÁêÜÈÅéÊúüÁöÑÂêàÁ¥ÑÂø´ÂèñÊ™îÊ°à
/// 
/// Â∞çÊáâÂéüÂßã Python ÂáΩÊï∏Ôºö
/// ```python
/// def clear_outdated_contract_cache(contract_path: Path, keep_days: int = 3):
/// ```
pub fn clear_outdated_contract_cache<P: AsRef<Path>>(contract_path: P, keep_days: u64) -> Result<(), Box<dyn std::error::Error>> {
    let contract_path = contract_path.as_ref();
    let contract_dir = contract_path.parent()
        .ok_or("ÁÑ°Ê≥ïÂèñÂæóÂêàÁ¥ÑÁõÆÈåÑ")?;
    
    let now = SystemTime::now();
    let keep_duration = std::time::Duration::from_secs(keep_days * 24 * 60 * 60);
    
    if contract_dir.exists() {
        for entry in std::fs::read_dir(contract_dir)? {
            let entry = entry?;
            let file_path = entry.path();
            
            // Ê™¢Êü•Ê™îÊ°àÊì¥Â±ïÂêç
            if let Some(extension) = file_path.extension() {
                if extension != "pkl" && extension != "lock" {
                    continue;
                }
            } else {
                continue;
            }
            
            // Ê™¢Êü•Ê™îÊ°àÂêçÁ®±ÂâçÁ∂¥
            if let Some(file_name) = file_path.file_name() {
                if let Some(name_str) = file_name.to_str() {
                    if !name_str.starts_with("contract") {
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                continue;
            }
            
            // Ê™¢Êü•Ê™îÊ°à‰øÆÊîπÊôÇÈñì
            if let Ok(metadata) = entry.metadata() {
                if let Ok(modified) = metadata.modified() {
                    if let Ok(duration_since_modified) = now.duration_since(modified) {
                        if duration_since_modified > keep_duration {
                            if let Err(e) = std::fs::remove_file(&file_path) {
                                log::warn!("ÁßªÈô§ÈÅéÊúüÂêàÁ¥ÑÂø´ÂèñÂ§±Êïó {}: {}", file_path.display(), e);
                            } else {
                                log::debug!("Â∑≤ÁßªÈô§ÈÅéÊúüÂêàÁ¥ÑÂø´Âèñ: {}", file_path.display());
                            }
                        }
                    }
                }
            }
        }
    }
    
    Ok(())
}

/// Ê∏ÖÁêÜÈÅéÊúüÁöÑÂêàÁ¥ÑÂø´ÂèñÊ™îÊ°àÔºà‰ΩøÁî®È†êË®≠‰øùÁïôÂ§©Êï∏Ôºâ
/// Â∞çÊáâ Python ÁöÑÈ†êË®≠ÂèÉÊï∏ keep_days=3
pub fn clear_outdated_contract_cache_default<P: AsRef<Path>>(contract_path: P) -> Result<(), Box<dyn std::error::Error>> {
    clear_outdated_contract_cache(contract_path, 3)
}

/// Ê™¢Êü•ÂêàÁ¥ÑÂø´ÂèñÊòØÂê¶Â≠òÂú®‰∏îÁÇ∫ÊúÄÊñ∞
/// ÂêàÁ¥ÑÊúÉÂú®‰∏äÂçà 8 ÈªûÂíå‰∏ãÂçà 2 ÈªûÊõ¥Êñ∞
/// 
/// Â∞çÊáâÂéüÂßã Python ÂáΩÊï∏Ôºö
/// ```python
/// def check_contract_cache(contract_path: Path) -> bool:
///     """check contract cache exists and is up-to-date.
///     Contracts will be update at 8 am and 2 pm.
///     Returns:
///         bool: True if cache exists and is up-to-date, else False.
///     """
///     if contract_path.exists():
///         contract_file_datetime = dt.datetime.utcfromtimestamp(
///             contract_path.stat().st_mtime
///         )
///         utcnow = dt.datetime.utcnow()
///         if utcnow.date() > contract_file_datetime.date():
///             return False
///         elif utcnow.hour >= 6:
///             if contract_file_datetime.hour < 6:
///                 return False
///         return True
///     else:
///         return False
/// ```
pub fn check_contract_cache<P: AsRef<Path>>(contract_path: P) -> bool {
    let contract_path = contract_path.as_ref();
    
    if !contract_path.exists() {
        return false;
    }
    
    let Ok(metadata) = contract_path.metadata() else {
        return false;
    };
    
    let Ok(modified) = metadata.modified() else {
        return false;
    };
    
    let Ok(duration_since_epoch) = modified.duration_since(UNIX_EPOCH) else {
        return false;
    };
    
    let contract_datetime = DateTime::<Utc>::from_timestamp(
        duration_since_epoch.as_secs() as i64,
        duration_since_epoch.subsec_nanos()
    );
    
    let Some(contract_datetime) = contract_datetime else {
        return false;
    };
    
    let now = Utc::now();
    
    // Â¶ÇÊûúÂø´ÂèñÊ™îÊ°àÊòØ‰ªäÂ§©‰ª•ÂâçÁöÑÔºåÂâáË™çÁÇ∫ÈÅéÊúü
    if now.date_naive() > contract_datetime.date_naive() {
        return false;
    }
    
    // Â¶ÇÊûúÁèæÂú®ÊòØ‰∏äÂçà 6 Èªû‰πãÂæåÔºå‰ΩÜÂø´ÂèñÊ™îÊ°àÊòØ‰∏äÂçà 6 Èªû‰πãÂâçÁöÑÔºåÂâáË™çÁÇ∫ÈÅéÊúü
    // ÈÄôÊòØÂõ†ÁÇ∫ÂêàÁ¥ÑÊõ¥Êñ∞ÊôÇÈñìÁöÑËÄÉÈáè
    if now.hour() >= 6 && contract_datetime.hour() < 6 {
        return false;
    }
    
    true
}

/// ÂâµÂª∫ÂÖ±‰∫´ÁõÆÈåÑÔºàÂ∞çÊáâ Python ÁöÑ create_shared_folderÔºâ
/// 
/// Â∞çÊáâÂéüÂßã Python ÂáΩÊï∏Ôºö
/// ```python
/// def create_shared_folder():
///     base_folder = Path.home() / ".shioaji"
///     base_folder.mkdir(exist_ok=True)
///     return base_folder
/// ```
pub fn create_shared_folder() -> Result<std::path::PathBuf, Box<dyn std::error::Error>> {
    let home_dir = dirs::home_dir()
        .ok_or("ÁÑ°Ê≥ïÂèñÂæó‰ΩøÁî®ËÄÖ‰∏ªÁõÆÈåÑ")?;
    
    let shared_folder = home_dir.join(".shioaji");
    
    std::fs::create_dir_all(&shared_folder)?;
    
    log::debug!("ÂÖ±‰∫´ÁõÆÈåÑ: {}", shared_folder.display());
    Ok(shared_folder)
}

/// ÂèñÂæóÂêàÁ¥ÑÂø´ÂèñÁõÆÈåÑÔºàÂ∞çÊáâ Python ÁöÑ CONTRACT_FOLDERÔºâ
pub fn get_contract_folder() -> Result<std::path::PathBuf, Box<dyn std::error::Error>> {
    let shared_folder = create_shared_folder()?;
    let contract_folder = shared_folder.join("contracts");
    
    std::fs::create_dir_all(&contract_folder)?;
    
    Ok(contract_folder)
}

/// ÂèñÂæóÂêàÁ¥ÑÊ™îÊ°àÂêçÁ®± (Â∞çÊáâÂéüÂßã Python ÁöÑ get_contracts_filename)
/// 
/// Â∞çÊáâÂéüÂßã Python ÂáΩÊï∏Ôºö
/// ```python
/// def get_contracts_filename():
///     return Path.home() / ".shioaji" / f"contracts-{__version__}.pkl"
/// ```
pub fn get_contracts_filename() -> Result<std::path::PathBuf, Box<dyn std::error::Error>> {
    let shared_folder = create_shared_folder()?;
    
    // üîë ÈóúÈçµ‰øÆÊ≠£Ôºö‰ΩøÁî®Á≥ªÁµ± shioaji Â•ó‰ª∂ÁâàÊú¨ÔºåËÄå‰∏çÊòØ rshioaji ÁâàÊú¨
    let shioaji_version = get_system_shioaji_version()?;
    let filename = format!("contracts-{}.pkl", shioaji_version);
    
    Ok(shared_folder.join(filename))
}

/// ÂèñÂæóÁ≥ªÁµ±ÂÆâË£ùÁöÑ shioaji Â•ó‰ª∂ÁâàÊú¨ (Â∞çÊáâÂéüÂßã Python ÁöÑ __version__)
/// 
/// Â∞çÊáâÂéüÂßã PythonÔºö
/// ```python
/// from shioaji import __version__
/// f"contracts-{__version__}.pkl"
/// ```
pub fn get_system_shioaji_version() -> Result<String, Box<dyn std::error::Error>> {
    use pyo3::prelude::*;
    
    Python::with_gil(|_py| -> Result<String, Box<dyn std::error::Error>> {
        let python_code = r#"
import shioaji
print(shioaji.__version__)
"#;
        
        let output = std::process::Command::new("python3")
            .arg("-c")
            .arg(python_code)
            .output()?;
        
        if output.status.success() {
            let version = String::from_utf8(output.stdout)?
                .trim()
                .to_string();
            log::debug!("üì¶ Á≥ªÁµ± shioaji ÁâàÊú¨: {}", version);
            Ok(version)
        } else {
            let error_msg = String::from_utf8(output.stderr)?;
            log::warn!("‚ö†Ô∏è ÁÑ°Ê≥ïÂèñÂæó shioaji ÁâàÊú¨: {}", error_msg);
            // ÂõûÈÄÄÂà∞È†êË®≠ÁâàÊú¨
            Ok("1.2.5".to_string())
        }
    })
}

/// ÂâµÂª∫Êñ∞ÁöÑ Contracts Áâ©‰ª∂ (Â∞çÊáâÂéüÂßã Python ÁöÑ new_contracts)
/// 
/// Â∞çÊáâÂéüÂßã Python ÂáΩÊï∏Ôºö
/// ```python
/// def new_contracts():
///     return Contracts()
/// ```
pub fn new_contracts() -> Contracts {
    Contracts::new()
}

/// ÂæûÊ™îÊ°àËºâÂÖ•ÂêàÁ¥ÑÂø´Âèñ (Â∞çÊáâÂéüÂßã Python ÁöÑ load_contracts_file)
/// 
/// Â∞çÊáâÂéüÂßã Python ÂáΩÊï∏Ôºö
/// ```python
/// def load_contracts_file():
///     contract_file = get_contracts_filename()
///     try:
///         with open(contract_file, 'rb') as f:
///             return pickle.load(f)
///     except Exception:
///         return None
/// ```
pub fn load_contracts_file() -> Result<Option<Contracts>, Box<dyn std::error::Error>> {
    let contract_file = get_contracts_filename()?;
    
    if !contract_file.exists() {
        log::debug!("ÂêàÁ¥ÑÂø´ÂèñÊ™îÊ°à‰∏çÂ≠òÂú®: {}", contract_file.display());
        return Ok(None);
    }
    
    // TODO: ÂØ¶‰ΩúÁúüÂØ¶ÁöÑÂêàÁ¥ÑÂø´ÂèñËºâÂÖ•Ê©üÂà∂
    // Áï∂ÂâçÂØ¶‰ΩúËàáÂØ¶ÈöõÈúÄÊ±Ç‰∏çÁ¨¶ÂêàÔºåÊö´ÊôÇÂõûÂÇ≥ None
    log::debug!("ÂêàÁ¥ÑÂø´ÂèñËºâÂÖ•ÂäüËÉΩÊö´Êú™ÂØ¶‰Ωú: {}", contract_file.display());
    Ok(None)
}

/// ÂÑ≤Â≠òÂêàÁ¥ÑÂø´ÂèñÂà∞Ê™îÊ°à (Â∞çÊáâÂéüÂßã Python ÁöÑ dump_contracts_file)
/// 
/// Â∞çÊáâÂéüÂßã Python ÂáΩÊï∏Ôºö
/// ```python
/// def dump_contracts_file(contracts):
///     contract_file = get_contracts_filename()
///     with FileLock(str(contract_file) + ".lock"):
///         with open(contract_file, 'wb') as f:
///             pickle.dump(contracts, f)
/// ```
pub fn save_contracts_file(contracts: &Contracts) -> Result<(), Box<dyn std::error::Error>> {
    let contract_file = get_contracts_filename()?;
    
    // Á¢∫‰øùÁõÆÈåÑÂ≠òÂú®
    if let Some(parent) = contract_file.parent() {
        std::fs::create_dir_all(parent)?;
    }
    
    // TODO: ÂØ¶‰ΩúÁúüÂØ¶ÁöÑÂêàÁ¥ÑÂø´ÂèñÂÑ≤Â≠òÊ©üÂà∂
    // Áï∂ÂâçÂØ¶‰ΩúËàáÂØ¶ÈöõÈúÄÊ±Ç‰∏çÁ¨¶ÂêàÔºåÊö´ÊôÇ‰ΩøÁî® JSON Ê†ºÂºèÂÑ≤Â≠òÂü∫Êú¨Ë≥áË®ä
    let contracts_json = serde_json::to_string_pretty(contracts)?;
    std::fs::write(&contract_file, contracts_json)?;
    
    log::info!("‚úÖ ÂêàÁ¥ÑÂø´ÂèñÂ∑≤ÂÑ≤Â≠ò (JSON Ê†ºÂºè): {} (Á∏ΩÊï∏: {})", 
             contract_file.display(), contracts.total_count());
    
    Ok(())
}

/// ÂâµÂª∫È†êË®≠ÁöÑÊ∏¨Ë©¶ÂêàÁ¥ÑË≥áÊñô (ÈñãÁôºÂíåÊ∏¨Ë©¶Áî®ÈÄî)
/// 
/// ÈÄôÂÄãÂáΩÊï∏Áî®ÊñºÂú®ÁÑ°Ê≥ïÂæû API Áç≤ÂèñÁúüÂØ¶ÂêàÁ¥ÑÊôÇÊèê‰æõÂü∫Êú¨ÁöÑÊ∏¨Ë©¶Ë≥áÊñô
pub fn create_default_test_contracts() -> Contracts {
    let mut contracts = new_contracts();
    
    // Ê∑ªÂä†‰∏Ä‰∫õÊ∏¨Ë©¶ËÇ°Á•®ÂêàÁ¥Ñ
    let test_stocks = vec![
        ("2330", "Âè∞Á©çÈõª"),
        ("2317", "È¥ªÊµ∑"),
        ("6505", "Âè∞Â°ëÂåñ"),
        ("2454", "ËÅØÁôºÁßë"),
        ("2412", "‰∏≠ËèØÈõª"),
    ];
    
    for (code, name) in test_stocks {
        let contract = crate::types::Contract {
            base: crate::types::BaseContract {
                security_type: crate::types::SecurityType::Stock,
                exchange: crate::types::Exchange::TSE,
                code: code.to_string(),
            },
            symbol: code.to_string(),
            name: name.to_string(),
            category: "ËÇ°Á•®".to_string(),
            currency: crate::types::Currency::TWD,
            delivery_month: String::new(),
            delivery_date: String::new(),
            strike_price: 0.0,
            option_right: crate::types::OptionRight::No,
            underlying_kind: String::new(),
            underlying_code: String::new(),
            unit: 1000.0,
            multiplier: 1,
            limit_up: 0.0,
            limit_down: 0.0,
            reference: 0.0,
            update_date: chrono::Utc::now().format("%Y-%m-%d").to_string(),
            margin_trading_balance: 0,
            short_selling_balance: 0,
            day_trade: crate::types::DayTrade::No,
            target_code: String::new(),
        };
        
        contracts.add_stock(code.to_string(), contract);
    }
    
    // Ê∑ªÂä†‰∏Ä‰∫õÊ∏¨Ë©¶ÊúüË≤®ÂêàÁ¥Ñ
    let test_futures = vec![
        "TXFA4", "TXFB4", "TXFC4",
    ];
    
    for code in test_futures {
        let contract = crate::types::Contract {
            base: crate::types::BaseContract {
                security_type: crate::types::SecurityType::Future,
                exchange: crate::types::Exchange::TAIFEX,
                code: code.to_string(),
            },
            symbol: code.to_string(),
            name: format!("ÊúüË≤®_{}", code),
            category: "ÊúüË≤®".to_string(),
            currency: crate::types::Currency::TWD,
            delivery_month: String::new(),
            delivery_date: String::new(),
            strike_price: 0.0,
            option_right: crate::types::OptionRight::No,
            underlying_kind: String::new(),
            underlying_code: String::new(),
            unit: 1.0,
            multiplier: 200,
            limit_up: 0.0,
            limit_down: 0.0,
            reference: 0.0,
            update_date: chrono::Utc::now().format("%Y-%m-%d").to_string(),
            margin_trading_balance: 0,
            short_selling_balance: 0,
            day_trade: crate::types::DayTrade::Yes,
            target_code: String::new(),
        };
        
        contracts.add_future(code.to_string(), contract);
    }
    
    contracts.update_counts();
    contracts.status = FetchStatus::Fetched;
    
    log::info!("üìã ÂâµÂª∫Ê∏¨Ë©¶ÂêàÁ¥ÑË≥áÊñô: ËÇ°Á•® {}, ÊúüË≤® {}", 
             contracts.counts.stocks, contracts.counts.futures);
    
    contracts
}

/// ÂàùÂßãÂåñ utils Ê®°ÁµÑ
pub fn init() -> Result<(), Box<dyn std::error::Error>> {
    // ËºâÂÖ•Áí∞Â¢ÉÈÖçÁΩÆ
    let config = EnvironmentConfig::from_env();
    if let Err(e) = config.validate() {
        eprintln!("Áí∞Â¢ÉËÆäÊï∏ÈÖçÁΩÆÈåØË™§: {}", e);
        std::process::exit(1);
    }
    
    // ÂàùÂßãÂåñÊó•Ë™åÁ≥ªÁµ±
    init_logging(&config)?;
    
    // ÂâµÂª∫ÂÖ±‰∫´ÁõÆÈåÑ
    if let Ok(shared_folder) = create_shared_folder() {
        log::debug!("ÂÖ±‰∫´ÁõÆÈåÑÂ∑≤ÂâµÂª∫: {}", shared_folder.display());
    }
    
    log::info!("üöÄ rshioaji utils Ê®°ÁµÑÂàùÂßãÂåñÂÆåÊàê");
    log::info!("üìä Áí∞Â¢ÉËÆäÊï∏: {}", config.summary());
    
    Ok(())
}



#[cfg(test)]
mod tests {
    use super::*;
    use std::env;
    
    #[test]
    fn test_environment_config_default() {
        let config = EnvironmentConfig::default();
        assert_eq!(config.log_level, "INFO");
        assert_eq!(config.legacy_test, 0);
        assert!(config.log_sentry);
    }
    
    #[test]
    fn test_environment_config_from_env() {
        // Ë®≠ÂÆöÊ∏¨Ë©¶Áí∞Â¢ÉËÆäÊï∏
        env::set_var("LOG_LEVEL", "DEBUG");
        env::set_var("LEGACY_TEST", "1");
        env::set_var("LOG_SENTRY", "False");
        
        let config = EnvironmentConfig::from_env();
        assert_eq!(config.log_level, "DEBUG");
        assert_eq!(config.legacy_test, 1);
        assert!(!config.log_sentry);
        
        // Ê∏ÖÁêÜÊ∏¨Ë©¶Áí∞Â¢ÉËÆäÊï∏
        env::remove_var("LOG_LEVEL");
        env::remove_var("LEGACY_TEST");
        env::remove_var("LOG_SENTRY");
    }
    
    #[test]
    fn test_config_validation() {
        let mut config = EnvironmentConfig::default();
        assert!(config.validate().is_ok());
        
        config.log_level = "INVALID".to_string();
        assert!(config.validate().is_err());
    }
    
    #[test]
    fn test_log_level_conversion() {
        let config = EnvironmentConfig::default();
        assert_eq!(config.get_log_level_filter(), LevelFilter::Info);
        assert_eq!(config.get_log_level(), Level::Info);
    }
    
    #[test]
    fn test_status_error_wrapper() {
        // ÊàêÂäüÂõûÊáâ
        let result = status_error_wrapper(200, "{\"success\": true}");
        assert!(result.is_ok());
        
        // Á©∫ÂõûÊáâ
        let result = status_error_wrapper(200, "");
        assert!(result.is_ok());
        
        // ÈåØË™§ÂõûÊáâ
        let result = status_error_wrapper(401, "{\"response\": {\"detail\": \"Unauthorized\"}}");
        assert!(result.is_err());
    }
    
    #[test]
    fn test_timeout_exception() {
        let error = timeout_exception("test_function", 408, "Request timeout");
        match error {
            crate::error::Error::Timeout(msg) => {
                assert!(msg.contains("test_function"));
                assert!(msg.contains("408"));
                assert!(msg.contains("Request timeout"));
            }
            _ => panic!("Expected Timeout error"),
        }
    }
    
    #[test]
    fn test_create_shared_folder() {
        // ÈÄôÂÄãÊ∏¨Ë©¶ÊúÉÂâµÂª∫ÂØ¶ÈöõÁõÆÈåÑÔºåÂú®ÂØ¶ÈöõÁí∞Â¢É‰∏≠ÊâçÈÅãË°å
        if std::env::var("RUST_TEST_CREATE_DIRS").is_ok() {
            let result = create_shared_folder();
            assert!(result.is_ok());
            
            let folder = result.unwrap();
            assert!(folder.exists());
            assert!(folder.file_name().unwrap() == ".shioaji");
        }
    }
} 